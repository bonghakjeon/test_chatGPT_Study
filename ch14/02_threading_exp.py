# 카카오톡 챗봇의 콘셉
# 카카오톡 챗봇의 기본 구조는 텔레그램 챗봇과 동일하게
# 아래처럼 4가지 구조로 나뉜다.
# 1) 기본 정보 설정 단계
# 2) 기능 함수 구현 단계
# 3) 서버 생성 단계
# 4) 메인 함수 구현 단계 
# 전체적인 구조는 텔레그램 챗봇과 동일하지만
# 4) 메인 함수 구현 단계 부분이 텔레그램 챗봇보다 훨씬 복잡하다.
# 이유는 카카오톡 서버 응답이 5초를 넘어가면 답변을 차단하기 때문이다.
# 이게 무슨 뜻인가 하면 카카오톡 채팅방에 사용자가 질문을 하면
# 해당 질문에 대한 답변을 카카오 챗봇이 해주는데
# 해당 챗봇이 5초 안에 답변을 하지 않으면 카카오톡 서버에서 답변을 차단한다.
# 카카오톡 채팅방에 채팅을 입력하고 챗봇 서버에서 OpenAI 서버로 
# ChatGPT에게 응답 또는 DALLE.2 에게 그림을 요청하고 그림 생성이 완료된 응답을
# 다시 한번 카카오톡 서버로 전송해야 하는데 5초라는 시간은 너무 짧고 가혹하다.
# ChatGPT의 응답은 어느 정도 커버가 가능하지만 
# DALLE.2의 경우는 그림 생성이 대부분 5초를 넘어가서
# 사실 5초 안에 답변 하는게 불가하다.
# 그러면 5초 안에 답변을 하지 않고 기다리고 있다가
# 답변이 다 완료된 후에 그냥 보내주면 되잖아요? 라고 생각할 순 있지만
# 카카오톡 챗봇 시스템은 텔레그램 처럼 언제 어느 시점에서나
# 카카오톡 챗봇이 사용자에게 메시지 전송을 할수 있는게 아니다
# 카카오톡 챗봇은 오직 사용자의 입력에 대한 답장만 가능하다.
# 그 답장을 5초를 넘어가면은 그 답장마저 못하고 차단된다.
# 카카오톡 채팅방 보면 카카오 플러스 채널이 굉장히 많은데
# 해당 카카오 플러스 채널들이 사용자에게 가끔씩 광고 메시지를 전송한다.
# 해당 광고 메시지는 카카오톡 채널 창에 메시지를 보내지 않았는데
# 알아서 광고 메시지를 사용자에게 보낸다.
# 이런 식으로 카카오톡 채널에서 사용자의 입력에 대한 답장이 아니라
# 임의로 채널에 있는 챗봇이 사용자에게 메시지를 보내는 것은 전부 유료 서비스이다.
# 즉, 각 회사들은 사용자한테 광고성 메시지를 보낼 때 다 돈을 내고 보내는 것이다.
# 단, 우리가 개발하는 카카오 챗봇 프로그램은 그렇게 돈을 내면서 까지 구현할 필요는 없고
# 사용자의 질문에 대한 답변 즉 무료로 사용자의 질문에 대한 답변을 5초 안에만 하면 된다.
# 하지만 5초 안에 답변을 하는 것은 불가능하기 때문에 해당 문제를 해결해야 한다.
# 해당 문제를 해결하는 방법은 아래처럼 2가지이다.
# 1. 카카오 "챗봇 관리자센터" -> "도움말" 들어가서 답변 응답시간을 늘려달라고 요청 
# (카카오 자체 심사 과정 통과하는 경우만 답변 응답시간 늘려줌)
# 2. 소스코드를 추가로 구현하여 사용자에게 일정 시간이 지난 후 다시 요청 받기
# 2번 소스코드 추가 구현 설명
# 상황 설명 
# 5초 안에 사용자에게 답변(텍스트, 그림) 받는 상황이다.
# 예를들어 사용자가 카카오 챗봇에게 그림 그려달라고 요청을 한 시점이 있다.
# 해당 시점 부터 OpenAI가 생성한 그림을 카카오 챗봇이 받는 시점이 3.5초 이내면 
# 바로 카카오 챗봇이 사용자에게 그림을 보낼 수 있다.
# 여기서 기준을 3.5초로 정한 이유는 
# 카카오 챗봇 -> 카카오톡 서버로 전송하는 시간을 대략 1.5초 정도로
# 여유롭게 확보를 하기 위해서 정한 기준이다.
# 이 경우에는 개발자가 따로 별도의 코드를 작성하지 않아도 
# 5초 안에 답변이 나가기 때문에 개발자가 별도로 코드를 작성할 필요가 없다.
# 하지만 문제는 다음과 같이 3.5초 이내로 OpenAI-DALLE.2로 부터 
# 그림을 전달받지 못하는 경우이다.
# 좀더 설명하자면 사용자가 카카오 챗봇에게 그림을 요청했고
# 그림이 생성되서 카카오톡 서버로 그림을 전송해주는 시점이 3.5초를 넘어갔다.
# 또는 그림이 생성되는 과정만 3.5초를 넘어갔다면 
# 개발자가 구현한 FastAPI 로컬 웹서버는 카카오톡 서버로 일단 먼저 "안내메세지"를 보내서 답장한다.
# 아래와 같은 "안내메시지"를 보내서 사용자에게 아래와 같은 추가 기능("버튼[생각 다 끝났나요?]")을 사용할 수 있게 해준다.
# "미안 조금만 기다려줘 지금 그림을 생성중인데 조금 시간이 걸려 내가 너무 미안하니까 대신에 "버튼[생각 다 끝났나요?]"을 하나 만들어 줄게
#  조금 시간이 지난 후에 해당 "버튼[생각 다 끝났나요?]"을 누르면 내가 생성된 그림을 보내줄 거야 라고 "안내메시지"를 보낸다."
# 다시 한번 정리 하자면 사용자가 카카오 챗봇에게 그림을 요청한 시점으로부터 
# 3.5초 내에 OpenAI-DALLE.2로 부터 그림을 받지 못하면은
# 개발자가 구현한 FastAPI 로컬 웹서버는 카카오톡 서버로 아래와 같은 "안내메세지"를 보내야 되는데
# "안내메시지"에는 "버튼[생각 다 끝났나요?]"을 하나 추가해서 보내야 한다.
# "지금 그림 생성을 못했으니까 일정 시간 지난 후에 다시 한번 이 버튼[생각 다 끝났나요?]을 누르면 우리가 완성한 그림을 보내줄거야"
# 라는 안내 메시지를 카카오톡 서버로 보낸다.
# 그렇게 "안내메시지"가 나간 후에 OpenAI-DALLE.2에서는 그림을 이미 다 그리고
# 개발자가 구현한 FastAPI 로컬 웹서버로 그려놓은 그림에 대한 정보를 넘겨준다.
# 그러면 일단 개발자가 구현한 FastAPI 로컬 웹서버에 OpenAI-DALLE.2가 그려놓은 그림을 저장하고 
# 개발자가 구현한 FastAPI 로컬 웹서버에서만 해당 그림을 가지고만 있다.
# 그리고 일정 시간 후에 개발자가 구현한 FastAPI 로컬 웹서버에서 
# 카카오톡 서버로 "안내메시지"와 같이 보내줬던 "버튼[생각 다 끝났나요?]"을 사용자가 보고
# "이제 그림 다 그렸나?" 라고 생각을 하고 "버튼[생각 다 끝났나요?]"을 클릭하면
# "버튼[생각 다 끝났나요?]"을 클릭한 메시지가 개발자가 구현한 FastAPI 로컬 웹서버로 전송되고
# 개발자가 구현한 FastAPI 로컬 웹서버는 사용자가 "버튼[생각 다 끝났나요?]"을 클릭하면
# 개발자가 구현한 FastAPI 로컬 웹서버에서 저장해놓은 
# OpenAI-DALLE.2가 그려놓은 그림을 가지고 와서 
# 사용자에게 카카오챗봇으로 그림을 전송 해주는 시스템이 되겠다.
# 여기서 굳이 버튼[생각 다 끝났나요?]을 만든 이유는 5초 지난 시점 이후에는 
# 개발자가 구현한 FastAPI 로컬 웹서버에서 카카오톡으로 그림을 보낼 수 잇는 방법이 없기 때문이다.
# 다시 한번 사용자에게 버튼[생각 다 끝났나요?]을 클릭하여 입력(이벤트)을 받기 위해서이다.
# 다시 한번 사용자에게 버튼[생각 다 끝났나요?]을 클릭하여 입력(이벤트)을 받으면
# 그 버튼[생각 다 끝났나요?]을 클릭한 입력(이벤트) 시점 부터 5초 이내로 
# 개발자가 구현한 FastAPI 로컬 웹서버에서 답장(그림이 포함된 답장)만 하면 되기 때문에
# 다시 한번 사용자에게 버튼[생각 다 끝났나요?]을 클릭하여 입력(이벤트)을 받기 위해서
# 개발자가 구현한 FastAPI 로컬 웹서버에서 "버튼[생각 다 끝났나요?]"을 생성해서 
# 카카오톡 챗봇 사용자에게 전달을 해주게 되는 것이다.
# 위에서 설명한 기능을 시연 설명을 하면 아래와 같다.
# 1) 카카오톡 채팅방에서 사용자가 "/img 따뜻한 여름 해변" 입력 및 엔터
# 2) 개발자가 구현한 FastAPI 로컬 웹서버가 카카오톡 서버로 아래 "안내메시지"와 "버튼[생각 다 끝났나요?]"을 생성해서 전송함/
# 3) 사용자는 약간의 시간 대략 3초~4초 정도 후에 "버튼[생각 다 끝났나요?]" 클릭
# 4) 개발자가 구현한 FastAPI 로컬 웹서버에서 저장해뒀던 
#    OpenAI-DALLE.2가 그려놓은 그림을 그제서야 카카오 챗봇을 통해서 사용자에게 전달하게 되는 방법이다.
# 5) 그렇게해서 사용자가 "버튼[생각 다 끝났나요?]"을 클릭하면 사용자가 메시지 "생각이 다 끝났나요?" 자동 생성 및 입력 처리
#    -> 카카오 챗봇 입장에서는 마치 "사용자가 생각이 다 끝났나요?" 라는 채팅을 입력한 것으로 인식한다.
#       이렇게 인식하면 카카오 챗봇은 OpenAI-DALLE.2가 그려놓은 그림을 그제서야 
#       사용자에게 전달하게 된다.
# 사실 애초에 카카오 챗봇이 사용자의 입력에 대한 답변 기능만 가능하고
# 사용자의 입력 없이 챗봇이 독단적으로 메시지를 보내는 것을 금지해놨기 때문에
# 위와 같이 복잡하게 구현을 해야한다.
# 이렇게라도 기능을 구현하면 사용자에게 OpenAI-DALLE.2가 그려놓은 그림을 보낼 수 있기 때문에
# 이런 방식으로 카카오 챗봇 프로그램을 구현한다.
# 그런데 이런 방법으로 코드를 구현하려면
# 카카오 챗봇은 동시에 아래 두 가지 작업을 하고 있어야 한다.
# 첫 번째, 3.5초를 카운팅 하면서 카카오 챗봇에게 우선 답장을 하는 작업
# 두 번째, 개발자가 구현한 FastAPI 로컬 웹서버가 OpenAI-DALLE.2가 그려놓은 그림을 받는 작업 
# 다만 잘 알다시피 프로그래밍 작업은 동시에 진행이 안 된다.
# 무조건 순서대로 이 작업이 끝나면 그 다음 작업, 
# 이 작업이 끝나면 그 다음 작업, 또 이 작업이 끝나야 그 다음 작업이 시작된다.
# 조금 더 전문적인 표현을 쓰자면 해당 작업 두가지를 동시에 멀티스레딩이라는 작업을 통해서 
# 일을 처리해야 한다.
# 멀티스레딩이란 동시에 코드에서 병렬적으로 2가지 이상의 여러 가지 작업을 진행하는 것을 뜻한다.
# 하여 파이썬 환경에서 멀티스레딩을 코드로 구현하기 위해 아래 소스코드를 참고 해야 한다.

# 아래와 같이 여러 작업스레드가 동시에 처리되는 것을 멀티스레딩이라고 부른다.
# 사실은 아래처럼 컴퓨터가 실제로 동시에 병렬로 여러 개 작업을 하는게 아니라
# 첫 번째 작업 "Thread1"을 조금 하고 그 다음에 두 번째 작업 "Thread2"을 조금 하고
# 그 다음에 세 번째 작업 "Thread3"을 조금 하고 
# 그리고 그 다음에 또 첫 번째 작업 "Thread1"을 조금 하고
# 그 다음에 두 번째 작업 "Thread2"을 조금 하고
# 이런 식으로 사실은 순서대로 진행을 하는데 
# 처음부터 끝까지 작업을 진행을 하고 다 함께 시작하는게 아니라
# 조금 조금씩 진행을 해서 마치 사용자가 느끼기에는 동시에
# 병렬적으로 여러 작업스레드를 처리하고 있구나라고 느낄 수 있다.
# 이것이 바로 멀티스레딩의 개념이다.

# *** 멀티스레딩 작업스레드 "Thread1", "Thread2", "Thread3" 실행 순서 ***
# 1. 첫 번째 작업 "Thread1" 시작 
# 2. 첫 번째 작업 "Thread1"이 끝나기 전에 두 번째 작업 "Thread2" 시작 
#    (두 번째 작업 "Thread2" 시작이 되면 사실상 첫 번째 작업 "Thread1"과 두 번째 작업 "Thread2"이 동시에 진행되는 상태이다.)
# 3. 두 번째 작업 "Thread2"도 끝나기 전에 세 번째 작업 "Thread3" 시작
#    (세 번째 작업 "Thread3" 시작이 되면 사실상 첫 번째 작업 "Thread1"과 두 번째 작업 "Thread2"과 세 번째 작업 "Thread3"이 동시에 진행되는 상태이다.)
# 4. 첫 번째 작업 "Thread1" 종료 
#    (두 번째 작업 "Thread2"과 세 번째 작업 "Thread3"이 동시에 진행되는 상태이다.)
# 5. 두 번째 작업 "Thread2" 종료 
#    (세 번째 작업 "Thread3"만 진행되는 상태이다.)
import threading   # 파이썬 내장 패키지 "threading" 불러오기 
import time        # 파이썬 내장 패키지 "time" 불러오기 

# 작업스레드 func0 함수
# 매개변수 list_var에 리스트 객체를 인자로 전달 받고
# for 반복문 돌려서 리스트에 속한 모든 요소를 
# 0.5초 간격으로 출력하는 함수   
def func0(list_var):
    for x in list_var:
        # 파이썬 str 함수 사용해서 int -> string 형변환
        # 참고 URL - https://codechacha.com/ko/python-convert-integer-to-string/
        print('func0-'+str(x))
        time.sleep(0.5)   # 0.5초 간격으로 대기(딜레잉) 처리

# 작업스레드 func1 함수 
# 매개변수 list_var에 리스트 객체를 인자로 전달 받고
# for 반복문 돌려서 리스트에 속한 모든 요소를 
# 1초 간격으로 출력하는 함수   
def func1(list_var):
    for x in list_var:
        # 파이썬 str 함수 사용해서 int -> string 형변환
        # 참고 URL - https://codechacha.com/ko/python-convert-integer-to-string/
        print('func1-'+str(x))
        time.sleep(1)   # 1초 간격으로 대기(딜레잉) 처리

if __name__=="__main__":
    ##### 멀티스레드(Thread) 미사용 #####
    # func0([1,2,3,4,5])
    # func1(["A","B","C","D"])
    # 비쥬얼스튜디오코드(VSCode) 터미널 출력 결과
    # 멀티스레드(Thread) 미사용 실행 순서 
    # 1) func0 함수 실행 
    # 2) func0 함수 종료
    # 3) func1 함수 실행
    # 4) func1 함수 종료 
    # 아래처럼 터미널창에 순서대로 출력  
    # func0-1
    # func0-2
    # func0-3
    # func0-4
    # func0-5
    # func1-A
    # func1-B
    # func1-C
    # func1-D

    ##### 멀티스레드(Thread) 사용 ######
    # thread 선언
    x1 =[1,2,3,4,5]
    x2 =["A","B","C","D"]
    # 아직까지는 작업스레드 객체가 t1, t2가 생성만 되고
    # 실제 작업스레드(함수)가 실행이 안된 상태이다.
    # threading.Thread 클래스 사용하여 작업스레드 객체 t1 생성 
    # 작업스레드 객체 t1 생성시 
    # 매개변수 target에는 작업스레드 t1으로 실행하고 싶은 함수(function) 이름 "func0" 인자로 전달
    # 매개변수 args에는 작업스레드 t1으로 실행하고 싶은 함수(function)에 
    # input으로 넣을 리스트 객체 "x1"를 인자로 전달 
    t1 = threading.Thread(target=func0,args=(x1,))
    # threading.Thread 클래스 사용하여 작업스레드 객체 t2 생성 
    # 작업스레드 객체 t2 생성시 
    # 매개변수 target에는 작업스레드 t2로 실행하고 싶은 함수(function) 이름 "func1" 인자로 전달 
    # 매개변수 args에는 작업스레드 t2로 실행하고 싶은 함수(function)에 
    # input으로 넣을 리스트 객체 "x2"를 인자로 전달 
    t2 = threading.Thread(target=func1,args=(x2,))
    # 비쥬얼스튜디오코드(VSCode) 터미널 출력 결과
    # 멀티스레드(Thread) 사용 실행 순서 
    # 1) func0 함수 실행 
    # 2) func1 함수 실행
    # 3) func0 함수 종료
    # 4) func1 함수 종료 
    # 아래처럼 터미널창에 순서대로 출력  
    # func0-1
    # func1-A
    # func0-2
    # func1-B
    # func0-3
    # func0-4
    # func1-C
    # func0-5
    # func1-D
    

    # 작업스레드 (t1, t2) thread 시작
    t1.start()   # 작업스레드 객체 t1의 함수 "func0" 시작
    t2.start()   # 작업스레드 객체 t2의 함수 "func1" 시작

    # 각각의 작업스레드 (t1, t2)가 완료가 되었을 때,
    # thread 종료
    t1.join()   # 작업스레드 객체 t1의 함수 "func0" 종료
    t2.join()   # 작업스레드 객체 t2의 함수 "func1" 종료


